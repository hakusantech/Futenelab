---
title: "東大生が教える！Python講座〜初級編"
excerpt: "Pythonの概念、用途、基本的な文法までをわかりやすく解説！簡単な競技プログラミングの問題を解けるところを初級編ではゴールに設定します。"
coverImage: "/assets/blog/python1/cover.jpg"
keywords: ["python", "東大", "Google Colab", "プログラミング入門", "コーディング", "エンジニア", "Pythonの基本文法", "初心者", "コード"]
date: "2025-03-04T12:00:00.000Z"
author:
  name: "Mai Saito"
  picture: "/assets/blog/authors/saitomai.jpg"
ogImage:
  url: "/assets/blog/python1/cover.jpg"
category: "backend"
featured: true
---

## 目次
0. はじめに
    - 何故この記事を書いたのか
    - なぜいまPythonを学ぶのか
    - この記事の目的
    - コードの実行方法
   

1. Pythonの概要
   - 1.1 Pythonとは何か
     - 歴史的背景と特徴（シンプルな文法、豊富なライブラリ、AIやデータ分析など幅広い分野で使用）
     - Pythonの思想
   
2. Pythonの基本文法
   - 2.1 コメントとインデント
     - コメント # の書き方
     - インデントの重要性とブロック構造
   - 2.2 変数とデータ型
     - 変数名の付け方、命名規則（PEP 8に軽く触れる）
     - 整数・浮動小数点数・文字列・ブール型など
   - 2.3 print関数での出力
     - 基本的な使い方
     - 文字列の連結、f文字列 や .format() メソッド
   - 2.4 演算子
     - 四則演算、比較演算子、論理演算子
     - 文字列の演算子（連結や繰り返し）

   -2.5　関数
    - プログラミングにおける「関数」とは
    - 関数の定義方法
    - 関数の呼び出し方法
    - 関数の引数と戻り値
    
    

3. 制御構文
   - 3.1 条件分岐
     - if, elif, else の基本構文
     - 簡単な例：数値判定（正負判定など）
   - 3.2 ループ処理
     - for 文：range との組み合わせ
     - while 文：条件に応じて繰り返す
   - 3.3 break / continue
     - 繰り返し処理の中断、処理スキップの方法

4. 基本的なデータ構造
   - 4.1 リスト（list）
     - 作り方・アクセス方法
     - 要素の追加・削除
     - リスト内包表記の簡単な導入
   - 4.2 タプル（tuple）
     - リストとの違い（イミュータブル）
     - タプルの利点と使いどころ
   - 4.3 辞書（dict）
     - キーと値、アクセス方法
     - 要素の追加・削除・更新
   - 4.4 セット（set）
     - 重複しない要素の集まり
     - 集合演算（和・差・積など）

5. 例外処理




6. モジュール・パッケージの利用
   - 6.1 標準ライブラリの紹介
     - math, random, datetime など定番ライブラリの説明
   - 6.2 import 文の使い方
     - import モジュール名
     - from モジュール名 import 関数名
   - 6.3 外部ライブラリの導入
     - pip install の基本
     - 実務で多用されるライブラリの紹介例（numpy, requests などをちらっと）

7. 本題　競技プログラミングの問題を解いてみよう！
   

8. 発展的な概念(中級編以降を読む予定がない方は飛ばして大丈夫です！)
   - 8.1 関数のスコープ
     - グローバルスコープとローカルスコープ
     - 変数のスコープと寿命
     - global キーワードの使い方
   - 8.2 オブジェクト指向プログラミング
     - オブジェクト指向とは
       - データと処理を一つのまとまりとして扱う考え方
       - 現実世界のモノや概念をプログラムで表現
     - クラスとオブジェクト
       - クラス：設計図やテンプレート
       - オブジェクト：クラスから作られる実体
     - オブジェクト指向の特徴
       - カプセル化：データと処理をまとめる
       - 継承：既存のクラスを拡張して新しいクラスを作る
       - ポリモーフィズム：同じインターフェースで異なる動作
     - メリットとデメリット
       - 利点：コードの再利用性、保守性の向上
       - 欠点：設計の複雑化、学習コストの増加


9.おわりに
   


## 0. はじめに
###  何故この記事を書いたのか
　　　
世の中にはすでに優れたPythonの入門記事がたくさん存在しています。しかし、筆者自身が大学1年生の頃にそれらの入門記事を読んだ際、環境構築でつまずいたり、「結局何ができるのか？」という目的が見えずモチベーションが下がったりした経験がありました。

そこで、ただ公式ドキュメントを薄くしたような内容の記事ではなく、最初から「解くべき問題（簡単な競技プログラミング形式の問題）」を設定しました。さらに、Google Colabを活用して環境構築の壁をなくし、コードを直接動かしながら、最終的に設定した問題を解くことによって、「コードでロジックを構成する」という体験を最短でゼロから味わっていただくためにこの記事を書いてみました。網羅度、実用性ともに自信ありの力作になっています。

### なぜいまPythonを学ぶのか
2025年現在、PythonはGitHub上で2番目に多く使用されているプログラミング言語です。2022年には前年比22%以上の成長を記録するなど、その人気はさらに高まり続けています（出典：Python Popularity: The Rise of a Language | Flatiron School）。このようにPythonが幅広く支持される背景には、データ分析や機械学習、ウェブ開発など、多様な分野での高い活用性があります。

特にAI開発においては、豊富なフレームワークと成熟したエコシステムにより、Pythonが事実上の標準（デファクトスタンダード）としての地位を確立しています。また、Pythonはシンプルで直感的な文法を持ち、初学者でも比較的簡単に習得できるという点も魅力です。

従来指摘されていた「型安全でない」「実行速度が遅い」といったPythonの課題も、近年ではFastAPIをはじめとした新しいフレームワークの登場により徐々に改善されています。こうした状況から、Pythonは初学者からプロのエンジニアまで幅広い層にとって、今後も学習価値の高いプログラミング言語であり続けると考えられます！

### この記事の目標
この記事の目的は、プログラミング経験が全くない初心者の方が、簡単な競技プログラミング（競プロ）の問題を自力で解けるようになることを目標にします。Hello Worldから始めるのもいいのですが、それだけではあまり面白くないですよね。ロジックをプログラミング言語で考える、という面白さをこの記事内で体験していただけるようにします。最初に本記事の最終目標の問題を示しておきましょう！


## 問題『偶数と奇数のカウント』

### 問題文

ある整数 N と、その後に続く N 個の整数が入力されます。

これらの整数の中から偶数の個数と奇数の個数をそれぞれ求め、

スペース区切りで「偶数の個数 奇数の個数」として出力してください。

### 入力形式

```

コピーする
N
a_1 a_2 a_3 ... a_N

```

- `N`：整数の個数（1 ≤ N ≤ 100）
- `a_i`：各整数（例として 1 ≤ a_i ≤ 1000）

### 出力形式

```

偶数の個数 奇数の個数

```

### 入力例

```

7
3 4 7 10 12 15 8

```

### 出力例

```

4 3

```

この問題を自力で解けるようになることを、本記事での到達目標とします！
### コードの実行方法

環境構築をローカルで行おうとするとその段階で多くの人がイヤになってしまうと思うので、Google Colabで実行していくことをお勧めします。
Google Colabとは、Googleが提供している無料のPython実行環境です。有料版もあるのですが重い機械学習モデルなどを動かさない限りは無料版で十分過ぎるほどの機能を提供してくれます.以下がリンクです

https://colab.research.google.com

### ① Google Colabにアクセスする

※Googleアカウントが必要なので、ログインしていない場合はログインしてください。

---

### ② 新しいノートブックを作成する

Google Colabのトップページが開いたら、

- 左上の **「ファイル」→「新しいノートブック」** をクリックします。

すると新しいノートブックが作成されます。

---

### ③ コードセルにコードを書く

新しいノートブックが表示されると、「セル」と呼ばれる枠の中にPythonコードを書くことができます。

例えば、簡単な例として以下のコードを入力してみてください：

```python

print("Hello, Colab!")

```

---

### ④ コードを実行する

セルにコードを書いたら、セルの左にある実行ボタン（▶️）をクリックするか、

- ショートカットキー `Shift + Enter`（または `Ctrl + Enter`）

を押してコードを実行します。

すると、コードの実行結果がセルの下に表示されます：

```

Hello, Colab!

```

---

### ⑤ 新しいコードセルを追加する

コードセルをさらに追加したい場合は、画面左上の「+ コード」をクリックすると、新しいコードセルが追加されます。

また、セルの上にカーソルを合わせると表示される「+ コード」でもセルを追加できます。

---

### ⑥ Pythonライブラリを追加する

Colab環境には基本的なライブラリが多くインストールされていますが、追加したいライブラリがある場合は以下のようにコードセルで`pip`を使ってインストールできます。

```bash

!pip install numpy pandas matplotlib

```

コードの前に`!`をつけることで、ターミナルコマンドを実行できます。

---

### ⑦ ファイルの保存とダウンロード

作業したノートブックは、自動的にGoogle Driveに保存されます。後でアクセスしたいときは、Google Driveの「Colab Notebooks」フォルダを見てください。

また、自分のパソコンに保存したい場合は、メニューの

- 「ファイル」→「ダウンロード」→「.ipynb をダウンロード」

をクリックするとダウンロードできます。

### 1.1 Pythonとは何か

### 歴史的背景と特徴

Pythonは、オランダ出身のプログラマー、グイド・ヴァンロッサム（Guido van Rossum）によって1989年に開発が始まりました。彼は「シンプルで読みやすく、誰でも使いやすい言語」を目指してこの言語を設計し、1991年に初めて一般公開しました。Pythonという名前は、イギリスのコメディ番組『モンティ・パイソン』から取られており、遊び心や親しみやすさを示しています。

Pythonは以下のような特徴を持っています。

- **シンプルで読みやすい文法**
- **豊富な標準ライブラリとサードパーティライブラリ**
- **Web開発、データ分析、機械学習・AI開発、科学計算など幅広い用途で使用可能**

現在では特に、AIやデータサイエンスの分野で絶大な人気を誇り、世界で最も使われているプログラミング言語の一つとなっています。

### Pythonの思想（The Zen of Python）

どのプログラミング言語にも独自のスタイルや思想があります。Pythonには特に、「パイソニック（Pythonic）」という言葉で表される、Pythonらしい書き方や考え方が存在します。その思想をユーモラスかつ端的に表現したものが「The Zen of Python（Pythonの禅）」という自由詩です。

実はPythonには、この禅の詩がイースターエッグとして内蔵されています。Pythonの対話型インタプリタ（REPL）で次のように入力すると、この詩を見ることができます。

```python
>>> import this

```

すると以下の詩が表示されます。

```
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one--and preferably only one--obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea--let's do more of those!

```

（日本語訳）

```
醜いより美しいほうがよい。
暗黙より明示のほうがよい。
複雑より単純のほうがよい。
極端な複雑よりただの複雑のほうがよい。
入れ子よりフラットのほうがよい。
密よりも疎のほうがよい。
読みやすさは大切だ。
特殊条件だからといって原則を破ってよいわけではないが、
実用性は純粋性に勝る。
わざと黙らされている場合を除き、
無言でエラーを次に渡してはならない。
曖昧なものが出てきたときに推測に頼るな。
仕事をするための当然の方法は1つある。むしろ、1つだけだと言いたいところだ。
ただし、オランダ人でなければ、最初からその方法を当然とは思わないかもしれないが。
今するのはしないままよりもよい。
もっとも、しないままのほうが慌てて今すぐするよりもよいことが多い。
実装を説明するのが難しいなら、それは悪いアイデアだ。
実装を説明するのが簡単なら、それはよいアイデアかもしれない。
名前空間はすばらしいアイデアの1つだ。もっとアイデアを出そう！

```

この「Zen（禅）」には、Pythonのプログラマーが心がけるべき原則が明確かつ簡潔に示されています。Pythonを学習・実践する際には、ぜひこの思想を意識しながら取り組んでみましょう。（といってもまだまだ先の話ですし、私自身もあまりできていません笑）




## 2. Pythonの基本文法を理解しよう！

---

## 2.1 コメントとインデント

### コメント (`#`) の書き方

コメントとは、「プログラムの動作に影響しないメモ書き」です。自分や他人がコードを見た時に、「何をしているのか」をわかりやすくするために使います。

Pythonでは、コメントを書くときは`#`（シャープ記号）の後にコメントを書きます。

```python

# これはコメントです。Pythonは実行しません。
print("Hello World")  # この行の後ろにもコメントが書けます！

```

- コメントは、コードの上や行末に書けます。
- コメントアウト（コードを一時的に無効にする）にも使えます。

```python

# print("この行は実行されないよ！")
print("この行だけ実行されるよ！")

```

### インデント（字下げ）の重要性とブロック構造

Pythonは **インデント（字下げ）でコードのまとまりを決めます。**

他のプログラミング言語は `{}`（中カッコ）などを使いますが、Pythonは「インデント」でブロックを示します。

- インデントには「スペース4つ」が推奨されています（これを統一しましょう！）。
- インデントがずれるとエラーになります。

例えば：

```python

if 3 > 1:
    print("3は1より大きいです。")  # インデントがあるので、ifの中
    print("ここもifの中です！")

print("これはifの外です！")  # インデントが戻るので、ifの外

```

インデントがない場合：

```python

if 3 > 1:
print("これはエラーになるよ！")  # インデントがないのでエラー

```

Pythonでは、「見やすく美しいコードを書く」ことを重視するため、インデントをきちんと整えることが重要です。

---

## 2.2 変数とデータ型

### 変数とは？

変数とは、**「データを入れておくための箱」** のようなものです。好きな値を入れたり、後で中身を変えたりできます。

Pythonでの変数の使い方：

```python

message = "こんにちは！"  # 変数messageに文字列を入れる
print(message)          # 中身を表示

```

中身を変えることも可能：

```python

message = "おはようございます！"  # 値を変更
print(message)

```

### 変数の命名規則（PEP 8）

変数名の付け方には、Pythonでは「PEP 8」という公式の推奨ルールがあります。

難しくないので、この3つだけ覚えておきましょう！

- 半角の英小文字を使います。数字も使えますが、数字で始めるのは禁止です。
    - 良い例：`user_name`, `total_price`, `count2`
    - ダメな例：`2count`, `UserName`, `total-amount`
- 複数の単語を組み合わせるときは、単語の間にアンダースコア（`_`）を入れます。
    - 良い例：`user_age`, `product_price`
- 変数名は意味がわかりやすいものにしましょう。
    - 良い例：`student_score`, `user_email`

---

### Pythonの主なデータ型

変数に入れることができるデータには「データ型」と呼ばれる種類があります。Pythonの主なデータ型を表にまとめました。

| データ型 | 説明 | 例 |
| --- | --- | --- |
| 整数型 (`int`) | 小数点がない整数 | `10`, `-3`, `0` |
| 浮動小数点数型 (`float`) | 小数点のある数値 | `3.14`, `-0.001`, `2.0` |
| 文字列型 (`str`) | 文字や記号の集まり。シングルクオートまたはダブルクオートで囲む | `"hello"`, `'Python'`, `"123"` |
| ブール型 (`bool`) | 真偽（正しいか誤りか）を表す | `True`, `False` |

使い方の例：

```python

age = 25                   # 整数
height = 170.5             # 浮動小数点数
name = "Taro"              # 文字列
is_student = True          # ブール型

# それぞれの変数の内容を確認
print(age)          # 25
print(height)       # 170.5
print(name)         # "Taro"
print(is_student)   # True

```

---

### データ型の確認方法

Pythonでは変数のデータ型を調べるために`type()`関数を使います。

```python

x = 100
y = 3.14
z = "Python"
is_valid = False

print(type(x))         # <class 'int'>
print(type(y))         # <class 'float'>
print(type(z))         # <class 'str'>
print(type(is_valid))  # <class 'bool'>

```

---

### 型変換（おまけ：便利！）

データ型を別の型に変換することもできます。


```python

# 整数 → 文字列
x = 10
x_str = str(x)
print(x_str)        # "10"

# 浮動小数点数 → 整数
y = 3.99
y_int = int(y)
print(y_int)        # 3 （小数点以下は切り捨て）

# 文字列 → 整数
z = "123"
z_int = int(z)
print(z_int)        # 123

```

---


## 2.3 `print`関数での出力

Pythonのプログラムを書いたら、その結果を画面に表示したいですよね。そのための命令が、`print`関数です。

### 基本的な使い方

使い方はとても簡単で、`print()`の中に表示したいものを入れます。

```python

print("Hello, Python!")  # 文字列を表示する
print(123)               # 数字も表示できるよ！
print(3 + 5)             # 計算結果も表示可能！

```

実行すると：

```

Hello, Python!
123
8

```

複数の値を表示するときは、コンマ`,`で区切ると、空白区切りで表示できます。

```python

name = "Taro"
age = 20
print("Name:", name, "Age:", age)

```

実行結果：

```

Name: Taro Age: 20

```

---

### 文字列の連結、f文字列、`.format()`メソッド

複数の値を文字列として1つにまとめて表示したいとき、次の3つの方法があります。

### ① 文字列の連結（`+`）

`+`演算子で文字列を連結できます。ただし、文字列以外の型は事前に文字列型に変換が必要です。

```python

name = "Taro"
age = 20

print("My name is " + name + ". I'm " + str(age) + " years old.")

```

結果：

```

My name is Taro. I'm 20 years old.

```

---

### ② f文字列（超おすすめ！）

Python3.6以降で一番便利なのが**f文字列**です。文字列の中に変数や式を簡単に入れることができます。

使い方は文字列の前に`f`をつけて、変数や式を`{}`の中に書くだけ！

```python

name = "Taro"
age = 20

print(f"My name is {name}. I'm {age} years old. Next year, I'll be {age + 1}.")

```

結果：

```

My name is Taro. I'm 20 years old. Next year, I'll be 21.

```

直感的で、読みやすいので、一番オススメ！

---

### ③ `.format()` メソッド（ちょっと昔の方法）

`.format()`も便利ですが、少し書き方が長くなります。

```python

name = "Taro"
age = 20

print("My name is {}. I'm {} years old.".format(name, age))

```

結果：

```

My name is Taro. I'm 20 years old.

```

`.format()`も実務でよく使われますが、最近はf文字列が主流です。

---

## 2.4 演算子

Pythonで計算を行ったり、比較をしたりするときに使う記号が**演算子**です。

---

### 四則演算（算数と同じ！）

まず基本の「四則演算」を見てみましょう。

| 演算子 | 意味 | 例 | 結果 |
| --- | --- | --- | --- |
| `+` | 足し算 | `5 + 2` | `7` |
| `-` | 引き算 | `5 - 2` | `3` |
| `*` | 掛け算 | `5 * 2` | `10` |
| `/` | 割り算 | `5 / 2` | `2.5` |
| `//` | 割り算の整数部分だけ | `5 // 2` | `2` |
| `%` | 割ったあまり | `5 % 2` | `1` |
| `**` | べき乗（〇乗） | `5 ** 2` | `25` |

```python

print(5 + 2)     # 7
print(5 - 2)     # 3
print(5 * 2)     # 10
print(5 / 2)     # 2.5
print(5 // 2)    # 2
print(5 % 2)     # 1
print(5 ** 2)    # 25

```

---

### 比較演算子（大小を比べる！）

比較演算子は、2つの値を比べて、真偽値（`True`または`False`）を返します。

| 演算子 | 意味 | 例 | 結果 |
| --- | --- | --- | --- |
| `>` | 大きい | `5 > 3` | `True` |
| `<` | 小さい | `5 < 3` | `False` |
| `>=` | 以上 | `3 >= 3` | `True` |
| `<=` | 以下 | `2 <= 1` | `False` |
| `==` | 等しい | `3 == 3` | `True` |
| `!=` | 等しくない | `3 != 3` | `False` |

```python

print(5 > 3)    # True
print(5 < 3)    # False
print(3 == 3)   # True
print(3 != 4)   # True

```

---

### 論理演算子（条件を組み合わせる！）

複数の条件を組み合わせる時に使います。

| 演算子 | 意味 | 例 | 結果 |
| --- | --- | --- | --- |
| `and` | 両方がTrueならTrue | `(5 > 3) and (3 > 1)` | `True` |
| `or` | どちらかがTrueならTrue | `(5 > 3) or (3 < 1)` | `True` |
| `not` | 真偽を反転 | `not(5 > 3)` | `False` |

```python

print((5 > 3) and (3 > 1))  # True
print((5 > 3) or (3 < 1))   # True
print(not(5 > 3))           # False

```

---

### 文字列の演算子（連結と繰り返し）

実は、文字列にも演算子があります。

| 演算子 | 意味 | 例 | 結果 |
| --- | --- | --- | --- |
| `+` | 文字列を連結 | `"Hello" + "World"` | `"HelloWorld"` |
| `*` | 文字列の繰り返し | `"Hi" * 3` | `"HiHiHi"` |

```python
greet = "Hello"
name = "Taro"
print(greet + " " + name)  # "Hello Taro"

repeat_word = "Wow!"
print(repeat_word * 3)     # "Wow!Wow!Wow!"

```

## ✅ めっちゃ重要なまとめ

- `print`関数は表示したい値や変数を表示するための基本。
- 複数の値は`,`で区切って表示できる。
- 文字列連結にはf文字列が一番オススメ！読みやすい！
- 四則演算は学校の算数と同じ、比較演算子は真偽を返す。
- 論理演算子は条件を組み合わせて複雑な条件を作るのに使える。
- 文字列にも演算子があり、連結（`+`）と繰り返し（）が可能。

## 2.5 関数（かんすう）

プログラミングではよく「関数（function）」という言葉が出てきます。

初めて聞くとちょっと難しそうですが、実はとってもシンプルで便利なものなんですよ！

順番に理解していきましょう！

---

### プログラミングにおける「関数」とは？

「関数」とは簡単に言うと、**ある特定の「処理」をまとめて名前をつけたもの** です。

- 同じような作業を何度もする場合、その作業をまとめておくと、毎回コードを書かなくても済みます。
- 短くて読みやすいコードになります。
- 必要な時に何回でも使い回しができます。

例えば「挨拶する」という処理を関数にしてみます。

イメージはこんな感じ：

```

挨拶をする関数 greet()
    ↓
「こんにちは！」と表示する

```

---

### 関数の定義方法

Pythonでは関数を定義する時に`def`というキーワードを使います。

基本的な書き方：

```python

def 関数名():
    やりたい処理

```

例えば、挨拶を表示する関数を作るならこうなります。

```python

# greetという関数を定義するよ！
def greet():
    print("こんにちは！")

```

- 関数の中身は必ずインデント（字下げ）します。
- 関数名はわかりやすくて短い名前をつけましょう。

---

### 関数の呼び出し方法

関数を作ったら、それを呼び出して使います。

呼び出し方はとても簡単です。

```python

関数名()

```

さっき作った`greet()`を呼び出してみましょう。

```python

# greetという関数を呼び出すよ！
greet()

```

実行すると：

```

こんにちは！

```

関数は1回作れば、何度でも呼び出せます。

```python

# 何度でも使える！
greet()
greet()

```

実行結果：

```

こんにちは！
こんにちは！

```

---

### 関数の「引数（ひきすう）」とは？

関数には「引数」というものを渡すことができます。

「引数」とは、関数に渡すデータ（情報）のことです。

関数が動くときに「必要な情報」を引数として渡します。

引数ありの関数の書き方：

```python

def 関数名(引数):
    処理

```

例えば、「名前」を渡すと、それを使って挨拶する関数を作ります。

```python

def greet(name):  # nameという引数を受け取る
    print(f"こんにちは、{name}さん！")

```

関数を呼び出すときに引数を渡します。

```python

greet("たろう")
greet("はなこ")

```

実行結果：

```

こんにちは、たろうさん！
こんにちは、はなこさん！

```

こうすると、関数がもっと柔軟で便利になりますよね。

---

### 関数の「戻り値（もどりち）」とは？

関数は処理の結果を返すこともできます。

この返される値のことを「戻り値（return value）」と言います。

戻り値がある関数の書き方：

```python

def 関数名(引数):
    処理
    return 戻したい値

```

例として「2つの数を渡して、それを足し算して結果を返す関数」を作ってみます。

```python

def add(a, b):     # 2つの引数 a と b を受け取る
    result = a + b # 足し算して result に保存
    return result  # result を戻り値として返す

```

関数の戻り値を変数に受け取って使います。

```python

answer = add(3, 5)  # 戻り値をanswerに代入
print(answer)

```

実行結果：

```

8

```

---

### 引数や戻り値を使った例をもうひとつ！

例えば、「好きな食べ物」と「嫌いな食べ物」を渡して、それを文章で返す関数を作りましょう。

```python

def foods(like, dislike):
    sentence = f"私は{like}が好きで、{dislike}が苦手です。"
    return sentence

# 呼び出して、戻り値を表示
result = foods("リンゴ", "ピーマン")
print(result)

```

結果：

```

私はリンゴが好きで、ピーマンが苦手です。

```

---

## ✅ 関数の重要ポイントまとめ

- 関数は **よく使う処理をまとめて名前を付けたもの**。
- 定義は`def 関数名()`で行い、呼び出すときは`関数名()`です。
- 引数を使って、関数に情報を渡せます。
- `return`で処理の結果を呼び出し元に返せます。
- 関数を使うと、コードが読みやすく、短く、整理されます。


## 3 制御構文（プログラムの流れを作る仕組み）

---

## 3.1 条件分岐 (`if`, `elif`, `else`)

Pythonで条件分岐を行うには、次の3つのキーワードを使います：

- **`if`**：「もし〜だったら」
- **`elif`**：「それ以外でもし〜だったら」（なくてもOK）
- **`else`**：「それ以外の場合」（なくてもOK）

この3つを使うと、条件に合わせて、プログラムを自由に分けて書くことができます。

---

### 基本構文（書き方のルール）

書き方はとてもシンプルで次のようになります。

```python

if 条件式:
    条件がTrue（真）のときに実行する処理
elif 別の条件式:
    ifがFalseのとき、elifの条件がTrueなら実行する処理
else:
    上のどれも当てはまらない場合の処理

```

- 「条件式」は、「真」か「偽」（`True` または `False`）になるような式を書きます。
- `if`の後、`elif`や`else`はあってもなくても大丈夫です。
- 条件に応じた処理は **必ずインデント（字下げ）して書きます。**

---

## 🔰 わかりやすい簡単な例（正負判定をしてみよう）

具体的に、数値が「正」「負」「ゼロ」かどうかを判定するプログラムを書いてみましょう！

### 例①：ifとelseを使ったシンプルな例（正 or それ以外）

```python

num = 10

if num > 0:
    print("正の数です！")
else:
    print("0または負の数です！")

```

このコードの意味：

- `num`が`0`より大きければ`正の数です！`と表示
- それ以外（`0`以下）なら`0または負の数です！`と表示

実行結果：

```

正の数です！

```

---

### 例②：if, elif, else を使って、もっと細かく分けてみよう（正, 負, ゼロ）

次は、0を含めて3つの場合に分けてみます：

```python

num = -5

if num > 0:
    print("正の数です！")
elif num == 0:
    print("ゼロです！")
else:
    print("負の数です！")

```

このコードの流れ：

- `num`が0より大きいかどうかチェック。大きければ「正の数です！」を表示。
- 0より大きくない場合、次に`num`がちょうど0かどうかチェック。0なら「ゼロです！」を表示。
- それも当てはまらなければ（残りは負の数しかない！）、最後の`else`に入り「負の数です！」を表示。

実行結果：

```

負の数です！

```

---

## 🔰 条件分岐の書き方をもう少し詳しく！

条件分岐をもっとよく理解するために、いろいろな例を見てみましょう。

### 💡 `elif`は複数書いてもOK

「もっと条件を細かく分けたいな…」という時は、`elif`を複数並べても大丈夫！

```python

score = 75

if score >= 90:
    print("成績：優秀")
elif score >= 70:
    print("成績：良好")
elif score >= 50:
    print("成績：合格")
else:
    print("成績：不合格")

```

実行結果：

```

成績：良好

```

上から順番に条件をチェックして、最初に当てはまった条件の処理を行います。

---

### 💡 条件を組み合わせることも可能（論理演算子）

複数の条件を同時にチェックする場合は、「論理演算子（`and`, `or`, `not`）」を使います。

```python

age = 25
has_license = True

if age >= 18 and has_license:
    print("車を運転できます！")
else:
    print("車を運転できません！")

```

実行結果：

```

車を運転できます！

```

---

### 💡 if文の中にif文を入れる（ネスト）

「条件の中にさらに条件を入れること」もできます。（少し上級）

```python

num = 20

if num > 0:
    if num % 2 == 0:
        print("正の偶数です。")
    else:
        print("正の奇数です。")
else:
    print("正の数ではありません。")

```

実行結果：

```

正の偶数です。

```

---

## 🚨【よくあるエラー】

Python初心者が条件分岐でよくやるミスが、「インデント（字下げ）の間違い」です。

ダメな例：

```python

num = 5

if num > 0:
print("正の数です！")  # インデントがないとエラーになるよ！

```

これはエラーになります。正しくは、

```python

num = 5

if num > 0:
    print("正の数です！")  # これでOK！

```

と必ずインデントしましょう！

---

## ✅ 条件分岐 (`if`, `elif`, `else`) まとめ

- 条件分岐とは「条件に応じて処理を分ける」仕組み。
- 書き方：
    
    ```python
    
    if 条件式:
        処理
    elif 別の条件式:
        処理
    else:
        その他の場合の処理
    
    ```
    
- 条件式は、真か偽 (`True`か`False`) になる式を使います。
- `elif`や`else`は省略できます。
- 処理は必ずインデントする。

## 3.2 ループ処理（繰り返しの処理）

プログラミングでは、何度も同じ処理を繰り返す場面がよくあります。

例えば、

- 「1〜100までの数字を順番に表示する」
- 「条件を満たす間、ずっと同じ処理を繰り返す」

こういう処理をまとめて行えるのが、**ループ処理（繰り返し処理）**です。

Pythonには主に2種類のループがあります：

- **`for`文**：決まった回数繰り返す
- **`while`文**：ある条件が成立している間だけ繰り返す

それぞれ詳しく見てみましょう！

---

## 3.2.1 `for`文（決まった回数繰り返す）

`for`文の基本的な書き方：

```python

for 変数 in 繰り返したいもの:
    繰り返したい処理

```

### `range()`と`for`文の組み合わせが基本！

Pythonで繰り返し回数を決めるときに最もよく使うのが、`range()`関数です。

例えば、「0〜4」までの数字を表示するには：

```python

for i in range(5):  # range(5) は 0,1,2,3,4 の5つ
    print(i)

```

実行結果：

```
0
1
2
3
4

```

ここでのポイント：

- `range(5)` は「0〜4」までの5回繰り返します。
- 変数`i`に順番に数字が入ります。

---

### 🔰 わかりやすい例（1〜10までの合計を計算する）

よくある例として、1〜10までの合計を出すコードを書いてみます。

```python

total = 0

for num in range(1, 11):  # range(1, 11) は1〜10までの数字
    total = total + num

print(f"1から10までの合計は {total} です！")

```

実行結果：

```

55

```

`range(1, 11)`と書くと「1以上11未満（つまり1〜10）」が指定されます。

---

### 🔰 もう一つ例（リストと組み合わせる）

実は`for`文は、リストの要素を順番に取り出すこともできます。

```python

fruits = ["りんご", "みかん", "バナナ"]

for fruit in fruits:
    print(f"私は{fruit}が好きです！")

```

結果：

```

私はりんごが好きです
私はみかんが好きです！
私はバナナが好きです！

```

---

## 3.2.2 `while`文（条件を満たしている間繰り返す）

`while`文は、ある条件が満たされている間、ずっと同じ処理を繰り返します。

書き方はこうです：

```python

while 条件式:
    繰り返したい処理

```

条件が`True`の間はずっとループを繰り返します。条件が`False`になったら止まります。

---

### 🔰 わかりやすい例（カウントダウンの表示）

「数字が0になるまでカウントダウンする」例を作ります。

```python

count = 5

while count > 0:
    print(count)
    count = count - 1  # count を1ずつ減らす

print("カウント終了！")

```

実行結果：

```

5
4
3
2
1

```

- `count > 0`の条件が満たされなくなる（`count`が0になったら）ループを終了します。

---

### 🔰 もう一つ例（条件によるループ終了）

`break`を使って、途中でループを終了することも可能です。

「入力された数字が0だったら終了、それ以外は表示」という例：

```python

while True:  # 無限ループ（条件を指定しない場合）
    num = int(input("数字を入れてください（0で終了）："))

    if num == 0:
        print("終了します！")
        break  # 0が入力されたら終了
    else:
        print(f"入力された数字は {num} です")

```

- `while True`は無限に繰り返します。
- ループ内で`break`があると、そこでループが終わります。

---

## ✅ `for`文 と `while`文 の使い分けまとめ（超重要！）

| 種類 | どんなときに使う？ | 特徴 |
| --- | --- | --- |
| `for`文 | 繰り返す回数が決まっているとき | リストや`range`を使う |
| `while`文 | 条件がTrueの間、繰り返し処理を続けるとき | 繰り返し回数がわからない時に便利 |

---

## ✅ 今回のポイントまとめ

- `for`文 は、決まった回数だけ繰り返すときに便利。
    
    ```python
    
    for i in range(3):
        print(i)  # 0,1,2 を順番に表示
    
    ```
    
- `while`文 は、ある条件が満たされている間、繰り返します。
    
    ```python
    
    num = 3
    while num > 0:
        print(num)
        num -= 1
    
    ```
    
- 途中でやめたい場合は、`break`を使います。

制御構文（`if`や`for`、`while`）をしっかり理解すると、自分が思った通りに自由自在にプログラムが書けるようになりますよ！

これであなたもループ処理マスターです🎉

# 3.2.3 `break` と `continue`（ループを止める・スキップする方法）

ループ処理をするとき、次の2つの場面がよくあります：

- 繰り返しの途中で **ループをやめたい**！
- 特定の条件だけ **処理を飛ばして次に進みたい**！

そんなときに使うのが、

- **`break`**（ループを中断する）
- **`continue`**（今の処理だけスキップして次へ）

です。

---

## ① `break` の使い方（繰り返しの途中でやめる）

### `break` とは？

`break` は **「繰り返し処理を途中で終了させる」** 命令です。

- `for`文でも`while`文でも使えます。
- `break`が実行されると、それ以降の処理はせずに、すぐに繰り返しを終了します。

---

### 🔰わかりやすい例（`for`文での`break`）

例えば、「1〜10まで順番に表示して、5になったら終了する」例を書きます。

```python

for num in range(1, 11):  # 1〜10まで繰り返す
    print(num)
    if num == 5:
        print("5になったので終了します！")
        break  # numが5になった瞬間に繰り返し終了

```

このコードを実行すると、

```

1
2
3
4
5
5になったので終了します！

```

- 5まで表示して終わります。
- `6`以降は表示されません！

---

### 🔰 もう一つ例（`while`文で`break`を使う）

「入力が特定の条件になったら終了」というよくある例です。

```python

while True:  # 無限に繰り返し
    text = input("終了したいときは exit と入力: ")
    if text == "exit":
        print("終了します！")
        break  # exitが入力されたらループ終了
    else:
        print(f"入力されたのは「{text}」でした。")

```

このコードは、ユーザーが「exit」と入力するまで、ずっと入力を求め続けます。

---

### 🔰 `break`を使った例まとめ

- 繰り返しの途中で終了したいときは **`break`を使う**。
- 主に「特定の条件で終了するループ」でよく使う。

---

## `continue`（処理をスキップして次へ進む）

`continue`は、ループの中で特定の条件だけ **処理をスキップして、次の繰り返しに進む** 命令です。

- 「ある特定の条件のときだけ処理をしたくない」場合に便利です。
- ループ自体は終了せず、次のループに移動します。

---

### 🔰 わかりやすい例（偶数だけスキップして表示する）

```python

for num in range(1, 6):  # 1〜5まで繰り返す
    if num % 2 == 0:     # 偶数ならスキップ
        continue
    print(num)  # 奇数のみ表示される

```

結果：

```

1
3
5

```

偶数（2と4）はスキップされて表示されません。

---

### 🔰 もう一つ例（特定の文字を飛ばして表示）

```python

text = "Python"

for char in text:
    if char == "h":
        continue  # hだけスキップ
    print(char)

```

結果：

```

P
y
t
o
n

```

「h」だけがスキップされましたね。

---

## ✅ `break` と `continue` の使い分けまとめ

| 命令 | 意味 | 使いどころ |
| --- | --- | --- |
| `break` | その時点で繰り返しを完全に終了 | 条件を満たしたらループを抜ける時 |
| `continue` | 今回の処理だけスキップし、次の繰り返しへ進む | 条件を満たした回だけ飛ばしたい時 |

---

## ✅ `break` と `continue`の超まとめ

- ループ処理の途中で中断するなら → **`break`**
- その回だけ飛ばして次に進みたいなら **`continue`を使う**。

どちらも覚えると、ループを自由自在に扱えるようになります！



# 4. 基本的なデータ構造

# 4.1 list(リスト）

## 

Pythonでプログラムを書くときに、最も頻繁に使われるデータ構造の1つが **リスト（list）** です。

まずはシンプルにリストを理解してみましょう。

---

## 🔰 リスト（list）とは？

リストとは、

**「複数のデータを1つの変数にまとめて、順番に並べて管理する」** データ構造です。

例えば、

- 買い物リスト：`["牛乳", "パン", "卵"]`
- 点数リスト：`[80, 95, 70, 85]`

のように、「同じ種類のデータをまとめて管理」できます。

---

## 📌 リストの基本的な使い方

### 📝 作り方

リストは、データを **カンマ（`,`）で区切って**、全体を**角かっこ `[ ]` で囲みます。

```python

# 数字のリスト
numbers = [10, 20, 30]

# 文字列のリスト
fruits = ["りんご", "バナナ", "ぶどう"]

# 混ざったリストも作れます
mixed = ["太郎", 20, True]

```

- リストはデータの種類がバラバラでも大丈夫です！

---

## 📌 リストへのアクセス方法（データの取り出し方）

リストの中の各データ（要素）には **「インデックス番号」** を使ってアクセスします。

インデックスは必ず **0から始まります！**

| 要素 | "りんご" | "バナナ" | "ぶどう" |
| --- | --- | --- | --- |
| インデックス | 0 | 1 | 2 |

実際のコード例：

```python

fruits = ["りんご", "バナナ", "ぶどう"]

print(fruits[0])  # 「りんご」
print(fruits[2])  # 「ぶどう」

```

実行結果：

```

りんご
ぶどう

```

インデックスがマイナスになると、後ろから順番にアクセスできます。

```python

print(fruits[-1])  # ぶどう（最後の要素）
print(fruits[-2])  # バナナ

```

---

## 📌 リストの要素を追加・削除する方法

リストは自由に要素を追加・削除できます。

### 🔰 要素の追加（append・insert）

- `append`で最後に要素を追加できます。

```python

fruits = ["りんご", "バナナ"]
fruits.append("みかん")  # 末尾に追加
print(fruits)  # ["りんご", "バナナ", "みかん"]

```

- 特定の位置に追加したい場合は`.insert()`を使います。

```python

fruits.insert(1, "いちご")  # インデックス1の位置に追加
print(fruits)  # ["りんご", "いちご", "バナナ", "みかん"]

```

---

### 🔰 要素の削除方法

- **`.remove(値)`** で値を指定して削除

```python

fruits.remove("バナナ")  # 「バナナ」を削除
print(fruits)  # ["りんご", "みかん"]

```

- *`.pop(インデックス)`*で指定位置を削除（何も指定しないと最後の要素を削除）

```python

removed_item = fruits.pop(0)  # 0番目の要素「りんご」を削除して取り出す
print(fruits)  # ["みかん"]
print(removed_item)  # 「りんご」が表示される

```

---

## 📌 リスト内包表記（リストをシンプルに作る書き方）

リスト内包表記とは、簡単なループ処理を1行で書ける、とても便利な方法です。

例えば、「1〜5をそれぞれ2倍したリスト」を作りたい場合、普通の方法だと：

```python

# 通常の書き方
numbers = []
for i in range(1, 6):
    numbers.append(i * 2)

print(numbers)  # [2, 4, 6, 8, 10]

```

↑これをリスト内包表記にすると…

```python

# 超スッキリした書き方！
numbers = [i * 2 for i in range(1, 6)]
print(numbers)  # [2, 4, 6, 8, 10]

```

- シンプルで読みやすくなります！

# 📌 4.2 タプル（tuple）

Pythonの基本的なデータ構造の1つである **タプル（tuple）** は、一言で言うと「変更できないリスト」のようなものです。

- 「イミュータブル（immutable＝不変）」という特徴を持ちます。
- 一度作成すると、中身を変更・追加・削除できません。

---

## 📌 タプルの作り方とアクセス方法

タプルは「丸括弧 `( )`」を使って作ります。

```python

# タプルの作り方（カッコで囲む）
colors = ("赤", "青", "黄色")

```

※ 要素が1つの場合は、最後に`,`（カンマ）が必要です。

```python

one_tuple = ("赤",)  # 要素1つのタプル

```

---

### 🔰 要素へのアクセス方法（リストと同じ）

リストと同様、インデックスでアクセスします（0から始まります）。

```python

colors = ("赤", "青", "黄色")

print(colors[0])  # 赤
print(colors[1])  # 青
print(colors[-1]) # 黄色（最後の要素）

```

---

## 📌リストとの違い（タプルの特徴：イミュータブル）

最大の違いは、タプルは **中身を変更・追加・削除できない** 点です。

- **変更可能（mutable）**：リスト（list）
- **変更不可（immutable）** → タプル（tuple）

| 操作 | リスト | タプル |
| --- | --- | --- |
| 要素の追加 | ⭕️（可能） | ❌（不可能） |
| 要素の変更 | ⭕️（可能） | ❌（不可能） |
| 要素の削除 | ⭕️（可能） | ❌（不可能） |

例を見てみましょう。

リストの場合は変更ができます。

```python
python
コピーする編集する
fruits = ["りんご", "みかん"]
fruits[0] = "いちご"  # 変更可能
print(fruits)  # ["いちご", "みかん"]

```

でも、タプルは変更できません！

```python

fruits_tuple = ("りんご", "みかん")

# これはエラーになる！
fruits_tuple[0] = "ぶどう"

```

実行すると、

```

TypeError: 'tuple' object does not support item assignment

```

というエラーが出ます。

「タプルは要素を変更できない！」ことを覚えておきましょう。

---

## 📌 なぜタプルを使う？（タプルの利点と使いどころ）

「変更できないなんて不便…？」と思うかもしれませんが、タプルには大きな利点があります。

タプルのメリット：

- **間違えてデータを書き換える心配がない**（安全性が高い）
- **データが変更されないことを明確に示せる**（意味的にわかりやすい）
- **速度が速い**（リストより処理が軽い）

---

## 🔰 タプルの使いどころ（具体例で理解！）

タプルはこんなときに便利です。

### ✅① 曜日や月名など、決して変わらないデータの管理

曜日や月の名前は普通、変えませんよね？

```python

weekdays = ("月", "火", "水", "木", "金", "土", "日")
print(weekdays[2])  # 水

```

これはリストでなくタプルで管理すると安全です。

### ✅② 複数の値をまとめて関数から返す時

関数から複数の値を返すときもタプルが使われます。

```python

def get_user():
    name = "太郎"
    age = 20
    city = "東京"
    return (name, age, city)

user_info = get_user()
print(user_info)  # ("太郎", 20, "東京")

```

---

### ✅ ②辞書のキーとして使える

リストは変更可能なのでキーに使えませんが、タプルは辞書のキーになれます。(辞書については後述します。

```python

locations = {
    (35.6895, 139.6917): "東京",
    (34.6937, 135.5023): "大阪"
}

print(locations[(34.6937, 135.5023)])  # 大阪

```

---

## 📌【比較表】リスト vs タプル（わかりやすく整理）

| 特徴 | リスト (`list`) | タプル (`tuple`) |
| --- | --- | --- |
| 作り方 | `[1, 2, 3]` | `(1, 2, 3)` |
| 要素の変更 | ⭕️できる | ❌できない（イミュータブル） |
| 追加・削除 | ⭕️可能 | ❌不可能 |
| メリット | 柔軟で使いやすい | 安全・速度が早い |

---

## 🚨 タプルを使うときの注意点（

- タプルの要素はあとから絶対に変更できません！
- 間違えて書き換えようとするとエラーになります。
- 要素が1つのタプルは最後に必ずカンマ`,`をつける。

---

## 🔰 例え（タプルとリストの違いを日常でイメージ）

| データ構造 | 日常での例え |
| --- | --- |
| リスト（変更可能） | メモ帳（いつでも書き換えできる📝） |
| タプル（変更不可能） | 印刷されたカレンダー（後から変更できない📅） |

例えば「タプル」は「駅の時刻表」のようなイメージです。

- 時刻表（タプル）は一度決めたら勝手に変えませんよね！
- 一方、メモ帳は書き換えたり、消したり、追加できます（リスト）。

---

## ✅タプルのポイント】

- タプルは **一度作ったら変更できないリスト**
- 作り方は丸カッコ `( )`を使う
- 中身のデータを変更したり追加・削除できない
- 「安全性」や「高速さ」が必要な場面で便利

これでタプルの理解は完璧！

リストとの違いをしっかり覚えておけば、使い分けが簡単になりますよ🎉


# 📌 4.3 辞書（dict）

辞書（dict）とは、「キー」と呼ばれる名前をつけて、それに対応する「値」をセットで保存するデータ構造です。

簡単にいうと、まさに「辞書」のような仕組みです。

例えば、現実の「辞書」は、

- 「りんご」→「apple」
- 「犬」→「dog」

のように単語（キー）と意味（値）がペアになっていますよね。

Pythonの辞書も全く同じイメージです。

---

## 📌 辞書の作り方（基本的な書き方）

辞書は`{}`（波かっこ）を使って作ります。

`キー: 値`のペアで表します。

```python

# シンプルな辞書の例
person = {"name": "たろう", "age": 25, "city": "東京"}

```

- `"name"`、`"age"`がキー、それに対する`"たろう"`と`25`が値です。

---

## 📌 辞書のキーと値へのアクセス方法

値にアクセスするには、インデックス番号ではなく「キー」を指定します。

```python

person = {"name": "たろう", "age": 25, "city": "東京"}

print(person["name"])  # 「たろう」
print(person["age"])   # 25

```

実行結果：

```

25

```

- 存在しないキーでアクセスするとエラーになるので注意しましょう。

---

## 📌 要素の追加・削除・更新

辞書の中身を変える方法はとても簡単です。

### 🔰 追加（新しいキーを指定して代入）

```python

person = {"name": "たろう", "age": 25}
person["city"] = "東京"  # cityというキーを追加
print(person)  # {'name': 'たろう', 'age': 25, 'city': '東京'}

```

---

### 🔰 更新（キーを指定して新しい値を代入）

```python

person["age"] = 26  # ageの値を更新
print(person)  # {'name': 'たろう', 'age': 26}

```

---

### 🔰 削除（`del`または`.pop()`）

```python

# delを使う方法
del person["age"]  # ageキーを削除
print(person)  # {'name': 'たろう'}

# またはpopで削除
removed_value = person.pop("name")  # nameを削除して値を取得
print(removed_item)  # たろう
print(person)  # {'age': 26}

```

---

## 📌【辞書の特徴まとめ】

- キーは重複不可（値は重複OK）
- 順番はなく、キーで管理される（最近のPythonは追加した順番を保持しますが、原則は順序なし）
- キーで素早く値にアクセスできるので非常に便利です。

---

# 📌 4.4 セット（set）

セット（set）とは、「重複しないデータの集まり」のことです。

数学で習う「集合」と同じイメージです。

- 同じデータは1つだけ入ります（重複がない）。
- 順番はありません（リストのようにインデックスは使えない）。

---

## 📌 セットの作り方

セットは`{}`を使いますが、辞書と違って値だけ書きます。

```python

numbers = {1, 2, 2, 3, 3, 4}
print(numbers)  # {1, 2, 3, 4}

```

- 重複する要素（3）は自動的に1つになります。

---

## 📌 セットの要素の追加・削除方法

セットは追加・削除が可能です。

### 🔰 追加 (`.add()`を使う)

```python

fruits = {"りんご", "バナナ"}
fruits.add("みかん")
print(fruits)  # {'りんご', 'バナナ', 'みかん'}

```

### 🔰 削除 (`.remove()`を使う)

```python

fruits.remove("バナナ")  # 指定した要素を削除
print(fruits)  # {'りんご', 'みかん'}

```

---

## 📌 セットの集合演算（和・差・積など）

集合演算がセット最大の利点です。

```python

A = {1, 2, 3}
B = {2, 3, 4}

print(A | B)  # 和集合（AかBのどちらかにある）→ {1,2,3,4}
print(A & B)   # 積集合 {2, 3}（共通部分）
print(A - B)    # 差集合 {1}（Aにしかないもの）

```

---

## 🚨 注意点：セットには順番がないのでインデックスでアクセス不可！

```python

numbers = {1, 2, 3}
# numbers[0] これはエラーになるよ！

```

---

## 📌【比較表】リスト・タプル・辞書・セットのまとめ

| 種類 | 順番 | 重複 | 追加・変更・削除 |
| --- | --- | --- | --- |
| リスト | ⭕️あり | ⭕️重複OK | ⭕️可能 |
| タプル | ⭕️あり | ⭕️重複OK | ❌不可能（イミュータブル） |
| 辞書 | △なし（キーで管理） | キーは❌重複不可（値は⭕️） | ⭕️可能 |
| セット | ❌なし | ❌重複不可 | ⭕️可能 |

---
## 🔰 辞書とセットを日常で例えると…

| データ構造 | 日常生活での例え |
| --- | --- |
| 辞書（dict） | 電話帳📖（名前がキーで、番号が値） |
| セット（set） | 福袋🎁（中身は重複せず、順番関係なし） |

---


# 📌 5. 例外処理（エラーを上手に扱う仕組み）

Pythonでプログラムを書いていると、「予期しないエラー」が発生することがあります。

そんなエラーが起きてもプログラムが止まらずにうまく動くようにするのが、**例外処理（try-except）** です。

---

## 📌 基本構文（書き方）

基本の構文はこうなります。

```python

try:
    # エラーが起きる可能性がある処理
except エラーの種類:
    エラーが起きた場合に行う処理

```

- **`try`** ブロックに「エラーが起きるかもしれない処理」を書きます。
- *`except`*でエラーが起きた場合の処理を書きます。

---

## 🔰 わかりやすい例（ゼロ除算エラーを回避）

例えば、0で割り算する（`10 / 0`）とエラーになります。

```python

try:
    result = 10 / 0  # 0で割ろうとしてエラーになる！
except ZeroDivisionError:
    print("0で割ることはできません！")

```

実行結果：

```

0で割ることはできません！

```

このようにエラーが起きてもプログラムを止めず、安全に処理できます。

---

## 📌 複数のエラーを処理する場合

複数の種類のエラーに対応する場合は、`except`を複数並べられます。

```python

try:
    num = int(input("整数を入力してください："))
    result = 10 / num
    print(result)

except ValueError:
    print("数値を入力してください。")
except ZeroDivisionError:
    print("0で割ることはできません。")

```

- 数字以外を入力すると → 「数値じゃない！」エラーをキャッチ。
- 0を入力すると → 「ゼロ除算エラー」をキャッチ。

---

## 📌 最後に必ず実行する処理（`finally`）

エラーの有無に関係なく、必ず最後に実行したい処理は、`finally`を使います。

```python

try:
    print(1 / 0)
except ZeroDivisionError:
    print("エラーが発生しました！")
finally:
    print("この処理は必ず実行されます。")

```

実行結果：

```

エラーが発生しました！
この処理は必ず実行されます。

```

- `finally` は、エラーが起きても起きなくても、絶対に実行したい処理を書きます（ファイルを閉じる時などに使う）。

---

## 📌 まとめ

- 例外処理は **「エラーが起きても安全に動作を継続する仕組み」**。
- 基本的に **`try`と`except`** を使って書く。
- エラーが起きても安全にプログラムを続けられる。


# 📌 6. モジュール・パッケージの利用

Pythonには、**モジュール**や**パッケージ**という便利な仕組みがあります。

簡単に言うと：

- **モジュール** は、「便利な機能がまとまったファイル（道具箱）」です。
- **パッケージ** は、「モジュールをさらにまとめたフォルダ（道具箱の棚）」です。

これを使うと、自分でゼロからコードを書かなくても、すぐに便利な機能を使えるようになります。

---

# 📌 6.1 標準ライブラリ（最初から入っている便利ツール）

Pythonには、最初から使える超便利なモジュール（標準ライブラリ）がたくさんあります。

その中でも、特に初心者がよく使う定番モジュールを紹介します。

---

## 📚① **math**（数学の関数を使えるモジュール）

- 数学的な計算（平方根、円周率など）が簡単に使えます。

使い方の例：

```python

コピーする編集する
import math

print(math.sqrt(16))  # 平方根を計算 (4.0)
print(math.pi)        # 円周率 (3.141592653589793)

```

---

## 🎲② **random**（ランダムな値を生成するモジュール）

- サイコロを振る、クジを引く、などランダムな処理をするときに便利。

使い方の例：

```python

コピーする編集する
import random

print(random.randint(1, 6))  # 1〜6までの整数をランダムに出力（サイコロ）
print(random.choice(["りんご", "バナナ", "みかん"]))  # ランダムに1つ選ぶ

```

---

## 🗓③ **datetime**（日付や時間を扱えるモジュール）

- 現在の日付や時刻、日付の計算が簡単にできます。

使い方の例：

```python

import datetime

now = datetime.datetime.now()  # 現在の日付と時刻を取得
print(now)

birthday = datetime.datetime(2000, 5, 10)  # 日付を指定して作成
print(birthday)

```

---

# 📌 6.2 `import`文の使い方（モジュールを読み込む方法）

モジュールを使うには、まず`import`を使って読み込みます。

## 🔰① `import モジュール名` のパターン

基本的にはこれを使います。

```python

import math  # mathモジュールを読み込み

print(math.factorial(5))  # 階乗を計算（120）

```

---

## 🔰② `from モジュール名 import 関数名` のパターン

特定の関数だけを読み込みたい時に使います。

```python

from random import randint  # randint関数だけを読み込み

print(randint(1, 10))  # randintだけ使える

```

---

## 📌【importの違いまとめ】

| 方法 | 特徴 | 使い分け |
| --- | --- | --- |
| `import モジュール名` | 全ての機能を使える | たくさんの機能を使いたい時 |
| `from モジュール名 import 関数名` | 特定の関数だけを簡単に使える | 一部の機能だけ使いたい時 |

---

# 📌 6.3 外部ライブラリの導入（さらに便利に！）

Pythonには「標準ライブラリ」にない機能を追加できる **外部ライブラリ** があります。

外部ライブラリを使うには、「インストール」が必要です。

---

## 📌【外部ライブラリのインストール（`pip install`）】

外部ライブラリはターミナル（コマンドプロンプト）でインストールできます。

書き方：

```bash

pip install ライブラリ名

```

例：numpy（科学計算に便利なライブラリ）をインストールするなら…

```bash

pip install numpy

```

※ColabやJupyter Notebookでは先頭に`!`をつけて実行します。

```python

!pip install numpy

```

---

## 📌 実務で多用される人気ライブラリ（ちらっと紹介）

初心者が将来、実務や仕事で役立つライブラリを紹介します。

### 📊① numpy（ナンパイ）

- 「科学計算・数値計算」に最強のライブラリ。
- 行列計算やデータ分析に必須。

```python
import numpy as np

arr = np.array([1, 2, 3])
print(arr * 10)  # [10, 20, 30]

```

---

### 🌐② requests（リクエスツ）

- 「Webサイトからデータを取得する」WebスクレイピングやAPI利用に最適。

```python

import requests

response = requests.get("https://www.google.com")
print(response.status_code)  # 成功すると200

```

---

### 🐼③ pandas（パンダス）

- データ分析・表データの操作に超便利なライブラリ。

```python

import pandas as pd

data = {"名前": ["たろう", "はなこ"], "年齢": [20, 22]}
df = pd.DataFrame(data)
print(df)

```

---

### 📈④ matplotlib（マットプロットリブ）

- グラフ作成が簡単にできる。データの可視化に使います。

```python

import matplotlib.pyplot as plt

plt.plot([1, 2, 3], [10, 20, 30])
plt.show()

```

---

## 📌【ライブラリ利用の流れまとめ】

外部ライブラリを使うときは以下の流れを覚えましょう：

```

① ライブラリをインストール（pip install）
↓
② モジュールをimportして使う

```

これだけでPythonが格段にパワーアップしますよ！




## 7. 本題　競技プログラミングの問題を解いてみよう！


問題を再喝します

## 問題『偶数と奇数のカウント』

### 問題文

ある整数 N と、その後に続く N 個の整数が入力されます。

これらの整数の中から偶数の個数と奇数の個数をそれぞれ求め、

スペース区切りで「偶数の個数 奇数の個数」として出力してください。

### 入力形式

```

コピーする
N
a_1 a_2 a_3 ... a_N

```

- `N`：整数の個数（1 ≤ N ≤ 100）
- `a_i`：各整数（例として 1 ≤ a_i ≤ 1000）

### 出力形式

```

偶数の個数 奇数の個数

```

### 入力例

```

7
3 4 7 10 12 15 8

```

### 出力例

```

4 3

```

### 実行方法（Google Colab）
Google Colabの新しいノートブックを開きます
上記のコードをセルに貼り付けます。
セルを実行（Shift + Enter または実行ボタン）します。
実行時に以下のように入力欄が表示されるので、まず整数の個数（例：7）を入力しEnter、続けて整数のリスト（例：3 4 7 10 12 15 8）を入力します。
結果として、「4 3」が出力されれば正解です。



```python

# 整数の個数を入力（標準入力から受け取る）
N = int(input())

# N 個の整数をスペース区切りで入力し、整数のリストに変換
numbers = list(map(int, input().split()))

```

これを入力して実行します、すると入力欄が表示されるので

```

7
```
```
3 4 7 10 12 15 8

```

これを入力して実行します、すると結果が出力されます　　この動作が確認できたら

```python

# 整数の個数を入力（標準入力から受け取る）
N = int(input())

# N 個の整数をスペース区切りで入力し、整数のリストに変換
numbers = list(map(int, input().split()))

```
この下にロジックを書いていってください。そしてまた実行して想定通りの結果が出たら正解です！

## 解説

### 解答例

```python

# 整数の個数を入力（標準入力から受け取る）
N = int(input())

# N 個の整数をスペース区切りで入力し、整数のリストに変換
numbers = list(map(int, input().split()))

# 偶数と奇数のカウント用変数を初期化
even_count = 0
odd_count = 0

# リスト内の各整数について偶数か奇数かを判定
for num in numbers:
    if num % 2 == 0:
        even_count += 1  # numが偶数の場合、even_countを1増やす
    else:
        odd_count += 1   # それ以外（奇数）の場合、odd_countを1増やす

# 結果をスペース区切りで出力
print(even_count, odd_count)

```



1. **入力の受け取り**
    - 最初に `N = int(input())` で整数の個数を受け取ります。※ここでは、生徒数ではなく、問題で与えられる整数の個数となります。
    - 次に、`numbers = list(map(int, input().split()))` により、スペース区切りで入力されたN個の整数を文字列から整数に変換し、リストにまとめます。
2. **偶数・奇数のカウント**
    - まず、`even_count` と `odd_count` という2つの変数を0で初期化します。
    - `for` 文でリスト `numbers` の各要素を順番に取り出し、`if num % 2 == 0:` で2で割った余りが0かどうかをチェックします。
        - 余りが0の場合は偶数なので、`even_count` を1増やします。
        - そうでなければ奇数なので、`odd_count` を1増やします。
3. **結果の出力**
    - 最後に `print(even_count, odd_count)` で、偶数の個数と奇数の個数をスペース区切りで出力します。

---

### 実行手順（Google Colab）

1. 既にColabのセットアップは完了している前提で、上記のコードをコードセルに貼り付けます。
2. セルを実行（Shift + Enter または実行ボタン）します。
3. 最初の入力欄に整数の個数（例：`7`）を入力しEnterキーを押します。
4. 次の入力欄に、スペース区切りの整数リスト（例：`3 4 7 10 12 15 8`）を入力しEnterキーを押します。
5. 結果として、「4 3」が出力されれば、プログラムは正しく動作しています。


# 8.1 関数のスコープ

「スコープ（scope）」という言葉を聞いたことがない人も多いと思います。

スコープとは、簡単にいうと**「変数が使える範囲」**のことです。

Pythonでは、大きく分けて以下の2つのスコープがあります。

- **グローバルスコープ**（global scope）
- **ローカルスコープ**（local scope）

また、スコープを理解すると、**変数の寿命**も理解できるようになります。

---

## 🔰 グローバルスコープとローカルスコープの違い

### ① グローバルスコープ（global scope）

グローバルスコープとは、プログラムの**どこからでも使える変数の範囲**です。

つまり、関数の外側で定義した変数は、全てグローバルスコープの変数となります。

### ② ローカルスコープ（local scope）

ローカルスコープとは、**関数の中だけで使える変数の範囲**です。

関数の中で定義した変数は、その関数内でしか使えません。

---

## 📌 わかりやすい例で理解する（グローバル vs ローカル）

例を見て理解しましょう：

```python

# グローバルスコープの変数（どこでも使える）
x = 10

def test():
    # ローカルスコープの変数（関数内だけで使える）
    y = 5
    print("関数内から:", x, y)  # x（グローバル）、y（ローカル）どちらも使える

test()  # 関数を実行

print("関数外から:", x)  # グローバルのxは使える
# print(y)  # ←これはエラーになる！yは関数内のみで使える変数だから

```

### 実行結果：

```

関数内から: 10 5
関数外から: 10

```

- 変数 `x` はグローバルスコープなので、関数内でも外でも使えます。
- 変数 `y` はローカルスコープなので、関数内だけで使えて、外では使えません。

---

## 🔰 変数のスコープと寿命について

変数には「寿命（lifetime）」があります。

これは「変数がいつまで存在するか」ということを意味します。

- グローバル変数はプログラムが終了するまでずっと存在します。
- ローカル変数は関数が呼び出されてから終了するまでの間だけ存在します。

例えば：

```python

def test():
    z = 20  # 関数のローカル変数
    print("関数内で作られた変数:", z)

test()
# print(z)  # ←関数の外に出ると変数zは消えてしまい使えません（エラー）

```

`z` は関数が呼び出されたときに作られ、関数の処理が終わると消えます。

---

## 📌 グローバル変数を関数の中で変更したい場合（globalキーワード）

関数内でグローバル変数を変更したい場合、そのまま使うと問題が発生します。

### 【エラーになる例】

```python

count = 10

def increment():
    count = count + 1  # ←実はこれはエラーになる
    print(count)

increment()

```

これは、関数内で`count`という新しいローカル変数を作ってしまうため、グローバル変数にアクセスできないのです。

この問題を解決するために、`global`キーワードを使います。

---

## 📌 global キーワードの使い方（わかりやすい例）

グローバル変数を関数内で変更したい時は、以下のように書きます。

```python

count = 10  # グローバル変数

def increment():
    global count  # 「関数内でグローバル変数countを使うよ！」と宣言
    count = count + 1
    print("関数内で変更した値:", count)

increment()
print("関数外で確認した値:", count)

```

### 実行結果：

```

関数内で変更した値: 11
関数外で確認した値: 11

```

このように`global`を使うことで、関数内でもグローバル変数を自由に変更できます。

---

## 🚨 global の注意点（むやみに使わない！）

`global` はとても便利ですが、むやみに使いすぎるとプログラムの挙動がわかりにくくなります。

- グローバル変数を多用すると、どこで値が変わったか分かりにくくなります。
- 可能ならば、関数には引数を渡し、戻り値を使って結果を受け取るようにするほうが良いでしょう。

**推奨する使い方（グローバルを避ける方法）：**

```python

count = 10

def increment(count):
    count += 1
    return count

count = increment(count)
print(count)  # 11

```

このように、関数には引数を渡し、戻り値を使って結果を受け取るようにするほうが良いでしょう。


## 8.2 オブジェクト指向プログラミング（Object Oriented Programming：OOP）

### オブジェクト指向とは

オブジェクト指向とは、プログラミングにおいて、データ（情報）とそのデータを操作する処理（メソッド）を一つのまとまりとして扱う考え方です。

### なぜ「オブジェクト」？

プログラムを作るとき、現実世界の「モノ」や「概念」をプログラムの中でも同じように扱えると便利ですよね。

オブジェクト指向では、こうした現実世界の「モノ（オブジェクト）」をプログラムの中に再現して扱います。

たとえば：

- **車**というオブジェクトなら「車種」「色」「速度」といったデータと、「走る」「止まる」といった動作をまとめて扱えます。
- 「人」なら、名前や年齢（データ）と「話す」「食べる」（処理）などをセットで考えます。

---

## 📌 オブジェクト指向の基本要素「クラス」と「オブジェクト」

### クラス（class）とは？

クラスとは「設計図」のようなものです。

つまり、「どんなデータを持っていて、どんな動作ができるか」をあらかじめ定義しておくものです。

具体的な例：

```python

# クラスの定義
class Person:
    # 初期化（データの定義）
    def __init__(self, name, age):
        self.name = name  # 名前
        self.age = age    # 年齢

    # 処理の定義（メソッド）
    def greet(self):
        print(f"こんにちは、私は{self.name}です。{self.age}歳です。")

```

- `class Person`で人間というクラスを定義します。
- `__init__` はオブジェクトが作られたときのデータを設定するための関数です。

---

### 📌 クラスからオブジェクトを作る（インスタンス化）

作ったクラスを使って、具体的なオブジェクト（人）を作ります。

```python

# Personクラスからオブジェクトを作成
taro = Person("太郎", 25)

# オブジェクトのデータにアクセス
print(taro.name)  # 太郎
print(taro.age)   # 25

```

このように、オブジェクトとは

**「クラスを具体化したもの」**

と言えます。

---

## 📌 オブジェクト指向の特徴（重要な3つの概念）

オブジェクト指向には、特に大切な次の3つの概念があります。

- **カプセル化（Encapsulation）**
- **継承（Inheritance）**
- **ポリモーフィズム（多態性）**

一つずつ、わかりやすく解説します。

---

## ✅① カプセル化（Encapsulation）

カプセル化とは、

「データ（変数）と処理（関数・メソッド）をまとめて1つのクラスとして管理する」ことです。

例えば：

```python

class Car:
    def __init__(self, brand, speed):
        self.brand = brand
        self.speed = speed

    def drive(self):
        print(f"{self.brand}の車が時速{self.speed}kmで走っています。")

my_car = Car("トヨタ", 120)
my_car.drive()

```

このように、データと処理を一体化することで管理が簡単になり、分かりやすくなります。

---

## 📌 継承（Inheritance）

継承とは、「既にあるクラスをもとにして、新しいクラスを作る仕組み」です。

- 既存クラスの機能をそのまま利用し、新しい機能だけを追加できます。
- コードの再利用や拡張が簡単になります。

例えば：

```python

# 元となるクラス（親クラス）
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print("動物の鳴き声です")

# Animalクラスを継承したDogクラスを作る
class Dog(Animal):
    def speak(self):
        print("ワン！")

dog = Dog()
dog.speak()   # ワン！（継承した新しい処理）
dog.speak()   # ワン！
dog.speak()   # ワン！

```

- 継承を使えば、共通の処理を繰り返し書かなくてもよくなります。

---

## 📌 ポリモーフィズム（Polymorphism・多態性）

ポリモーフィズムとは、「同じ名前（インターフェース）の処理であっても、クラスごとに異なる動きをさせる」ことです。

例えば、

```python

class Animal:
    def speak(self):
        print("動物の鳴き声")

class Dog(Animal):
    def speak(self):
        print("ワン！")

class Cat(Animal):
    def speak(self):
        print("ニャー！")

animals = [Dog(), Animal()]

for animal in animals:
    animal.speak()

```

結果：

```
コピーする編集する
ワン！
動物の鳴き声です

```

`speak()`という同じメソッド名でも、クラスによって動きが違います。これが多態性です。

---

## 📌 オブジェクト指向プログラミングのメリット

- **コードが整理され、読みやすくなる**（処理とデータがまとまっているから）
- **コードの再利用**がしやすく、繰り返しが減る
- **プログラムの保守性が高まり**、拡張しやすくなる

---

## 📌【まとめ】オブジェクト指向とは何だったか？

| 概念 | 内容 | 利点 |
| --- | --- | --- |
| **カプセル化** | データと処理をまとめる | 管理が楽、ミスが減る |
| **継承** | 既存のクラスを拡張して新しいクラスを作る | コードの再利用で効率化 |
| **ポリモーフィズム** | 同じメソッド名でもクラスごとに異なる動作 | 同じ操作を統一的に扱える |

オブジェクト指向はプログラミングを現実世界に近づけて考えるための重要な考え方です。

これを理解しておけば、複雑なプログラムもシンプルで整理されたものになります。


## 9. おわりに

ここまでお読みいただき、お疲れさまでした！

この記事を通じて、Pythonの基本的な文法やデータ構造、簡単な競技プログラミング問題を通して「コードでロジックを構成する」という体験をしていただけたかと思います。

今回学習した内容を通じて、Pythonを使ったプログラミングの楽しさや面白さを少しでも感じていただければ嬉しいです。

次のステップとして、以下のような中級編の記事を予定しています。

- データ分析・可視化 編：
    
    Pythonを使って実際のデータを分析し、グラフなどを使った視覚化の方法を学びます。
    
- Pythonでのソフトウェア開発 基本編：
    
    Pythonを用いて実際のソフトウェア開発をするために必要な知識や実践的なスキルを身につけます。
    
- アルゴリズムとデータ構造 編：
    
    より高度な競技プログラミング問題に挑戦するためのアルゴリズムやデータ構造について学習します。
    

ぜひご自身が一番興味のある分野を選んで、次のステップに進んでいただければと思います。

それでは、引き続きPythonの世界を楽しんでいきましょう！